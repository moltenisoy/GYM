Informe de Implementación y Arquitectura: Sistema de Gestión de Clientes Python (Madre-Hijo) para Windows




I. Visión General de la Arquitectura y Decisiones Tecnológicas




A. Resumen Ejecutivo de la Solución


Este informe presenta un prototipo funcional (Prueba de Concepto, POC) que implementa la arquitectura de red "Madre-Hijo" (Servidor-Cliente) solicitada, optimizada para su despliegue en la plataforma Windows utilizando el lenguaje Python. La solución se adhiere a las mejores prácticas actuales, proporcionando una base robusta, moderna y escalable.
La arquitectura se materializa en dos aplicaciones distintas:
1. Aplicación Hija (Cliente): Una aplicación de escritorio con una Interfaz Gráfica de Usuario (GUI) moderna, construida con la biblioteca CustomTkinter. Esta aplicación requiere autenticación contra el servidor central antes de desbloquear su funcionalidad principal.
2. Aplicación Madre (Servidor): Una aplicación híbrida única que funciona simultáneamente como un panel de gestión de escritorio (también usando CustomTkinter) y como un servidor API de backend (usando FastAPI).
En respuesta a la solicitud de que el entregable principal sea el "código mínimo funcional", este informe está estructurado en torno al código fuente completo y anotado de ambas aplicaciones. El código se presenta dentro de un análisis de arquitectura esencial que justifica las decisiones tecnológicas tomadas (por ejemplo, CustomTkinter sobre PySide6, FastAPI sobre sockets puros) y explica en detalle los patrones de implementación críticos, como la concurrencia de hilos (threading) en la Aplicación Madre.


B. Flujo de Datos Arquitectónico: Autenticación y Sincronización


El diseño se centra en dos flujos de comunicación remota clave, ambos basados en un modelo de petición/respuesta HTTP simple y robusto.


Flujo de Autenticación (Inicio de la Hija)


Este flujo describe el proceso de arranque de la aplicación Hija, que depende de la aprobación de la Madre.
1. Inicio (Hija): La Aplicación Hija se lanza en el equipo cliente. Inmediatamente presenta una GUI de inicio de sesión.1
2. Entrada de Usuario (Hija): El usuario introduce su nombre_de_usuario asignado en un campo de entrada.
3. Petición (Hija): Al pulsar "Conectar", la aplicación Hija utiliza la biblioteca requests 3 para enviar una petición $HTTP POST$ a la API de la Aplicación Madre. La petición se dirige a un endpoint específico (ej. http://ip_madre:8000/autorizar) y transporta el nombre de usuario dentro de un cuerpo JSON.4
4. Procesamiento (Madre): El servidor FastAPI de la Madre recibe la petición. El framework valida automáticamente el cuerpo JSON entrante contra un modelo Pydantic predefinido (ej. AuthRequest).5
5. Verificación (Madre): La lógica del endpoint consulta su "base de datos" interna para verificar si el nombre_de_usuario existe y si su permiso de acceso está habilitado (gestionado a través de la GUI de la Madre).
6. Respuesta (Madre): La Madre responde con un mensaje JSON, (ej. {"status": "aprobado", "usuario": "usuario_valido"} o {"status": "denegado"}).
7. Transición (Hija): La Hija recibe la respuesta. Si el estado es "aprobado", destruye el frame (marco) de inicio de sesión y, en su lugar, instancia y muestra el frame de la aplicación principal, desbloqueando la funcionalidad.7 Si es "denegado", muestra un mensaje de error.


Flujo de Sincronización (Iniciado por la Hija)


Este flujo permite a la Madre enviar actualizaciones de contenido, recursos o metadatos a una Hija que ya está autenticada.
1. Petición (Hija): El usuario, dentro de la aplicación Hija principal, presiona un botón de "Actualizar" o "Sincronizar".
2. Identificación (Hija): La aplicación Hija utiliza requests 9 para enviar una petición $HTTP GET$ a un endpoint de sincronización (ej. http://ip_madre:8000/sincronizar_datos). Para identificarse, incluye su nombre de usuario como un parámetro de consulta (query parameter) en la URL 10, (ej. .../sincronizar_datos?usuario=usuario_valido).
3. Procesamiento (Madre): El servidor FastAPI recibe la petición, extrae el usuario del parámetro de consulta 12 y recupera los datos de sincronización más recientes asociados a ese usuario (o los datos globales).
4. Respuesta (Madre): La Madre responde con un JSON que contiene los datos de sincronización solicitados (ej. {"contenido_actualizado": "...", "metadatos_version": "2.1"}).
5. Actualización (Hija): La Hija recibe el JSON, procesa los datos y actualiza sus recursos locales o su GUI (por ejemplo, poblando un cuadro de texto con el nuevo contenido).


C. Justificación de la Pila Tecnológica Seleccionada


La elección de cada componente tecnológico se ha basado en un equilibrio entre modernidad, escalabilidad, facilidad de implementación y el cumplimiento de las restricciones del proyecto (notablemente, el límite de 4 archivos .py).


GUI (Madre e Hija): CustomTkinter


* Análisis: La solicitud exige una GUI "moderna", "escalable" y "compleja". La investigación de frameworks de GUI de Python para Windows identifica varios contendientes, incluyendo Tkinter, PySide6/PyQt6, Kivy y CustomTkinter.13
* Decisión Estratégica: Si bien PySide6 (Qt) es reconocido como el estándar de oro para aplicaciones de software profesionales y de gran envergadura 14, su curva de aprendizaje y la complejidad de su estructura (incluyendo la posible ofuscación de código si se usa Qt Designer 16) lo hacen menos ideal para un prototipo "mínimo funcional" con un límite de archivos estricto. CustomTkinter se selecciona como la opción óptima. Proporciona la estética "moderna" y "atractiva" solicitada 1 sobre la base estable y nativa de Tkinter, que viene incluida con Python. Su API simple permite un desarrollo rápido, cumpliendo con todos los requisitos visuales y de escalabilidad sin la sobrecarga de un framework más pesado.


API del Servidor (Madre): FastAPI


* Análisis: La Aplicación Madre requiere un mecanismo de red para gestionar la autenticación y la sincronización. Las opciones arquitectónicas incluyen sockets de bajo nivel, gRPC 19 o un framework de API web.
* Decisión Estratégica: El flujo de comunicación solicitado no es un streaming bidireccional de baja latencia (descartando WebSockets 20) ni una comunicación de contrato estricto de alto rendimiento entre microservicios (haciendo que gRPC sea excesivo 19). El modelo es transaccional y basado en Petición/Respuesta. FastAPI es la elección superior para este modelo. Es un framework web de alto rendimiento 21 que utiliza Pydantic para la validación automática de datos 5 y proporciona un sistema de dependencias robusto para la seguridad.22 Esto permite definir endpoints limpios (ej. /autorizar) que validan automáticamente las solicitudes JSON entrantes 6, reduciendo drásticamente el código repetitivo de validación y aumentando la robustez del servidor.


Cliente de Red (Hija): requests


* Análisis: La Aplicación Hija debe consumir la API RESTful expuesta por la Madre.
* Decisión Estratégica: La biblioteca requests es el estándar de oro de facto en el ecosistema de Python para realizar peticiones HTTP. Su API intuitiva simplifica enormemente el envío de datos JSON (usando el argumento json=) 3 y la gestión de parámetros de consulta (usando el argumento params=) 9, que son las dos operaciones centrales requeridas por la Hija.


Multitarea (Madre): threading


* Análisis: Este es el desafío arquitectónico central de la Aplicación Madre. Debe ser, simultáneamente, una aplicación de escritorio con GUI y un servidor web. La ejecución de una aplicación GUI (ej. app.mainloop()) es un bucle bloqueante.24 De manera similar, la ejecución de un servidor web (ej. uvicorn.run()) es también un proceso bloqueante.25 Ambos no pueden ejecutarse en el mismo hilo.
* Decisión Estratégica (Patrón de Servidor GUI Responsivo): La única solución viable es ejecutar estos dos procesos bloqueantes en hilos separados. Las mejores prácticas para las GUI dictan que el bucle principal de la interfaz (CustomTkinter) debe ejecutarse en el hilo principal del proceso para garantizar la capacidad de respuesta y evitar cuelgues.24 Por lo tanto, el servidor FastAPI/uvicorn se iniciará en un hilo de fondo separado (threading.Thread).25 Este hilo se configurará como un "daemon" para que se cierre automáticamente cuando el usuario cierre la ventana principal de la GUI de la Madre. Esto permite que el administrador interactúe con el panel de gestión sin interrupciones, mientras el servidor atiende simultáneamente las solicitudes de las Hijas en la red.


D. Tabla 1: Resumen de Arquitectura y Tecnologías




Componente
	Función
	Tecnología Elegida
	Justificación (Basada en Investigación)
	GUI (Madre/Hija)
	Interfaz de usuario moderna y escalable.
	CustomTkinter
	Proporciona una estética moderna [1, 17] con una complejidad de código mínima, cumpliendo la restricción de 4 archivos.[18]
	Servidor API (Madre)
	Endpoint para autenticación y sincronización.
	FastAPI
	Alto rendimiento, validación de datos integrada (Pydantic) [6, 21], ideal para modelos de Petición/Respuesta.
	Cliente de Red (Hija)
	Consumo de la API de la Madre.
	requests
	Estándar de la industria para clientes HTTP. Manejo simple de JSON (json=) 4 y parámetros (params=).[10]
	Concurrencia (Madre)
	Ejecución simultánea de GUI y Servidor API.
	threading
	Permite que el servidor uvicorn (bloqueante) 25 se ejecute en un hilo de fondo, manteniendo la GUI (bloqueante) 24 responsiva en el hilo principal.
	Estructura GUI (Hija)
	Flujo de "Login" a "App Principal".
	Conmutación de Frames
	Patrón simple para mostrar/ocultar vistas. Se usará un método de destrucción/recreación para una gestión de memoria limpia.7
	Estructura GUI (Madre)
	Panel de gestión complejo.
	CTkTabview, CTkScrollableFrame
	Widgets de CustomTkinter ideales para construir un dashboard modular y escalable.[26, 27, 28]
	________________


II. Implementación de la Aplicación Madre (Servidor de Gestión)


A continuación, se presenta la estructura de archivos y el código fuente completo y anotado para la Aplicación Madre. Esta implementación respeta la restricción de un máximo de 4 archivos .py.


A. Estructura de Archivos (Total: 4 archivos.py)


1. madre_db.py:
   * Propósito: Simula una base de datos. Actúa como un módulo de estado compartido al que pueden acceder tanto el hilo de la GUI como el hilo del servidor.
   * Contenido: Define los diccionarios de Python que almacenan la lista de usuarios, sus permisos y los datos de sincronización.
2. madre_server.py:
   * Propósito: Define la lógica del servidor API.
   * Contenido: Contiene la instancia de la aplicación FastAPI, los modelos de datos Pydantic 5 y todos los endpoints de la API (ej. /autorizar y /sincronizar_datos).
3. madre_gui.py:
   * Propósito: Define la interfaz gráfica de usuario del panel de gestión.
   * Contenido: Contiene las clases de CustomTkinter para la ventana principal, el CTkTabview del dashboard 26 y el CTkScrollableFrame para la gestión de usuarios.27
4. madre_main.py:
   * Propósito: Punto de entrada y orquestador de la aplicación.
   * Contenido: Importa los componentes de la GUI y del servidor. Inicia el servidor FastAPI en un hilo de fondo 25 y luego inicia la aplicación GUI en el hilo principal.24


B. Código Fuente Completo y Anotado: Aplicación Madre


A continuación se muestra el contenido de cada uno de los 4 archivos .py.


madre_db.py




Python




# madre_db.py
#
# Este archivo actúa como una base de datos en memoria simple.
# Es importado tanto por 'madre_server.py' como por 'madre_gui.py'.
# Esto permite que tanto el servidor API como la interfaz gráfica de gestión
# lean y escriban desde la misma fuente de verdad.
#
# NOTA SOBRE CONCURRENCIA: En una aplicación de producción, el acceso a estos
# diccionarios desde hilos separados (GUI y Servidor) debería estar
# protegido por un 'threading.Lock' para garantizar la seguridad del hilo
# (thread-safety). Para este prototipo mínimo, confiamos en el
# Global Interpreter Lock (GIL) de Python para operaciones atómicas simples.

# Base de datos de usuarios. La clave es el nombre de usuario.
# El valor es un diccionario que contiene sus datos, incluido el permiso de acceso.
USER_DB = {
   "usuario_alfa": {"permiso_acceso": True, "datos_adicionales": "Equipo A"},
   "usuario_beta": {"permiso_acceso": True, "datos_adicionales": "Equipo B"},
   "usuario_gamma": {"permiso_acceso": False, "datos_adicionales": "Equipo C"},
}

# Base de datos de sincronización. Almacena el contenido que las Hijas
# descargarán cuando soliciten una sincronización.
SYNC_DATA = {
   "contenido": "Este es el contenido inicial desde la Madre.",
   "metadatos_version": "1.0.0"
}



madre_server.py




Python




# madre_server.py
#
# Define la lógica del servidor API usando FastAPI.
# Esta API será consumida por las Aplicaciones Hijas.
# Importa la base de datos en memoria desde 'madre_db'.

from fastapi import FastAPI, Query, HTTPException
from pydantic import BaseModel
from typing import Dict, Any

# Importar la base de datos compartida
import madre_db

# Crear la instancia de la aplicación FastAPI 
app = FastAPI(title="Servidor API de la Aplicación Madre")

# --- Modelos de Datos (Pydantic) ---
# Pydantic se usa para la validación de datos de solicitud. [5, 29]
# Define la estructura esperada del JSON en la petición POST de autorización.
class AuthRequest(BaseModel):
   username: str = Field(..., min_length=1, description="Nombre de usuario que intenta iniciar sesión")

# --- Endpoints de la API ---

@app.post("/autorizar", summary="Autoriza el inicio de sesión de una Aplicación Hija")
async def autorizar_usuario(auth_request: AuthRequest):
   """
   Endpoint de autenticación.
   Recibe un nombre de usuario y comprueba si existe en la USER_DB
   y si su 'permiso_acceso' está establecido en True.
   """
   usuario = auth_request.username
   
   if usuario in madre_db.USER_DB:
       if madre_db.USER_DB[usuario].get("permiso_acceso", False):
           # Usuario encontrado y con permiso
           return {"status": "aprobado", "usuario": usuario}
       else:
           # Usuario encontrado pero sin permiso
           raise HTTPException(status_code=403, detail="Permiso de acceso denegado por el administrador.")
   else:
       # Usuario no encontrado
       raise HTTPException(status_code=404, detail="Nombre de usuario no encontrado.")

@app.get("/sincronizar_datos", summary="Proporciona datos de sincronización a una Hija")
async def obtener_datos_sync(
   # Usa 'Query' para hacer el parámetro 'usuario' obligatorio. [11, 30]
   usuario: str = Query(..., description="El nombre de usuario de la Hija que solicita los datos")
):
   """
   Endpoint de sincronización.
   Verifica que el usuario solicitante es válido antes de entregar
   los datos de sincronización.
   """
   if usuario not in madre_db.USER_DB:
       raise HTTPException(status_code=404, detail="Usuario solicitante desconocido.")
       
   # Si el usuario es válido, devuelve el contenido de SYNC_DATA
   return {
       "status": "sincronizacion_exitosa",
       "datos": madre_db.SYNC_DATA
   }

@app.get("/", summary="Endpoint raíz de estado")
async def root():
   """
   Endpoint simple para verificar que el servidor está en línea.
   """
   return {"mensaje": "Servidor de la Aplicación Madre está en línea."}



madre_gui.py




Python




# madre_gui.py
#
# Define la Interfaz Gráfica de Usuario (GUI) para la Aplicación Madre
# usando CustomTkinter.
# Esta GUI permite al administrador gestionar los permisos de usuario y
# actualizar el contenido de sincronización.

import customtkinter
from typing import Dict, Any

# Importar la base de datos compartida
import madre_db

# Configuración inicial de apariencia (opcional, pero recomendada)
customtkinter.set_appearance_mode("dark")
customtkinter.set_default_color_theme("blue")

class Dashboard(customtkinter.CTkTabview):
   """
   Panel de control principal, implementado como un CTkTabview. [26, 31]
   Crea pestañas separadas para la gestión de usuarios y la sincronización.
   """
   def __init__(self, master, **kwargs):
       super().__init__(master, **kwargs)
       
       # Crear y añadir pestañas
       self.add("Gestión de Usuarios")
       self.add("Sincronización de Contenido")
       
       # Poblar cada pestaña
       self._crear_pestaña_usuarios()
       self._crear_pestaña_sincronizacion()

   def _crear_pestaña_usuarios(self):
       """Puebla la pestaña 'Gestión de Usuarios'."""
       tab_usuarios = self.tab("Gestión de Usuarios")
       tab_usuarios.grid_columnconfigure(0, weight=1)
       
       lbl_titulo = customtkinter.CTkLabel(tab_usuarios, text="Gestión de Permisos de Usuarios", font=customtkinter.CTkFont(size=16, weight="bold"))
       lbl_titulo.grid(row=0, column=0, padx=20, pady=(10, 5), sticky="w")
       
       lbl_desc = customtkinter.CTkLabel(tab_usuarios, text="Habilite o deshabilite el acceso para las Aplicaciones Hijas.")
       lbl_desc.grid(row=1, column=0, padx=20, pady=(0, 10), sticky="w")

       # El CTkScrollableFrame es esencial para listas largas de usuarios. 
       self.scrollable_frame_usuarios = customtkinter.CTkScrollableFrame(tab_usuarios, height=300)
       self.scrollable_frame_usuarios.grid(row=2, column=0, padx=20, pady=10, sticky="nsew")
       self.scrollable_frame_usuarios.grid_columnconfigure(0, weight=1)

       btn_actualizar = customtkinter.CTkButton(tab_usuarios, text="Actualizar Lista", command=self._actualizar_vista_usuarios)
       btn_actualizar.grid(row=3, column=0, padx=20, pady=10)
       
       # Poblar la lista por primera vez
       self._actualizar_vista_usuarios()

   def _actualizar_vista_usuarios(self):
       """
       Limpia y vuelve a poblar el frame desplazable con los usuarios de madre_db.
       """
       # Limpiar widgets antiguos
       for widget in self.scrollable_frame_usuarios.winfo_children():
           widget.destroy()
           
       # Volver a poblar con datos frescos de madre_db.USER_DB
       for i, (username, data) in enumerate(madre_db.USER_DB.items()):
           permiso_actual = data.get("permiso_acceso", False)
           
           # Crear un frame para cada fila de usuario
           user_frame = customtkinter.CTkFrame(self.scrollable_frame_usuarios)
           user_frame.grid(row=i, column=0, padx=10, pady=5, sticky="ew")
           user_frame.grid_columnconfigure(1, weight=1)
           
           lbl_user = customtkinter.CTkLabel(user_frame, text=username, font=customtkinter.CTkFont(weight="bold"))
           lbl_user.grid(row=0, column=0, padx=10, pady=5, sticky="w")
           
           lbl_datos = customtkinter.CTkLabel(user_frame, text=f"({data.get('datos_adicionales', 'N/A')})", text_color="gray")
           lbl_datos.grid(row=0, column=1, padx=10, pady=5, sticky="w")
           
           # El 'command' del switch modifica directamente la base de datos en memoria.
           # Usamos una lambda para pasar el 'username' al método de conmutación.
           switch_permiso = customtkinter.CTkSwitch(
               user_frame, 
               text="Acceso Habilitado",
               command=lambda u=username: self._conmutar_permiso(u)
           )
           if permiso_actual:
               switch_permiso.select() # Marcar el switch si el permiso es True
               
           switch_permiso.grid(row=0, column=2, padx=10, pady=5)

   def _conmutar_permiso(self, username: str):
       """
       Invierte el estado de 'permiso_acceso' para un usuario en madre_db.
       """
       if username in madre_db.USER_DB:
           nuevo_estado = not madre_db.USER_DB[username].get("permiso_acceso", False)
           madre_db.USER_DB[username]["permiso_acceso"] = nuevo_estado
           print(f"Permiso para '{username}' actualizado a: {nuevo_estado}")
           # Se podría añadir un refresco automático de la lista si se desea
           # self._actualizar_vista_usuarios() 
           
   def _crear_pestaña_sincronizacion(self):
       """Puebla la pestaña 'Sincronización de Contenido'."""
       tab_sync = self.tab("Sincronización de Contenido")
       tab_sync.grid_columnconfigure(0, weight=1)
       tab_sync.grid_rowconfigure(1, weight=1)
       
       lbl_titulo = customtkinter.CTkLabel(tab_sync, text="Publicar Contenido para Sincronización", font=customtkinter.CTkFont(size=16, weight="bold"))
       lbl_titulo.grid(row=0, column=0, padx=20, pady=(10, 5), sticky="w")

       self.textbox_sync = customtkinter.CTkTextbox(tab_sync)
       self.textbox_sync.grid(row=1, column=0, padx=20, pady=10, sticky="nsew")
       self.textbox_sync.insert("1.0", madre_db.SYNC_DATA.get("contenido", ""))
       
       btn_publicar = customtkinter.CTkButton(tab_sync, text="Publicar Nuevo Contenido", command=self._publicar_sync_data)
       btn_publicar.grid(row=2, column=0, padx=20, pady=10)

   def _publicar_sync_data(self):
       """
       Toma el texto del CTkTextbox y lo guarda en madre_db.SYNC_DATA.
       """
       nuevo_contenido = self.textbox_sync.get("1.0", "end-1c") # Obtener todo el texto
       madre_db.SYNC_DATA["contenido"] = nuevo_contenido
       # Actualizar la versión (lógica simple de ejemplo)
       try:
           version_actual = float(madre_db.SYNC_DATA["metadatos_version"])
           nueva_version = version_actual + 0.1
           madre_db.SYNC_DATA["metadatos_version"] = f"{nueva_version:.1f}"
       except ValueError:
           madre_db.SYNC_DATA["metadatos_version"] = "1.0"
           
       print(f"Nuevos datos de sincronización publicados. Versión: {madre_db.SYNC_DATA['metadatos_version']}")
       

class AppMadre(customtkinter.CTk):
   """
   Clase principal de la aplicación GUI.
   Contiene la ventana raíz y el Dashboard.
   """
   def __init__(self):
       super().__init__()
       
       self.title("Aplicación Madre - Panel de Control")
       self.geometry("800x600")
       
       self.grid_columnconfigure(0, weight=1)
       self.grid_rowconfigure(0, weight=1)
       
       self.dashboard = Dashboard(self, width=780, height=580)
       self.dashboard.grid(row=0, column=0, padx=10, pady=10, sticky="nsew")




madre_main.py




Python




# madre_main.py
#
# Punto de entrada principal para la Aplicación Madre.
# Este script orquesta el lanzamiento de los dos componentes principales:
# 1. El servidor FastAPI (en un hilo de fondo).
# 2. La aplicación GUI de CustomTkinter (en el hilo principal).

import threading
import uvicorn
from madre_gui import AppMadre
from madre_server import app as app_servidor

# Define la IP y el puerto para el servidor.
# '0.0.0.0' lo hace accesible desde cualquier IP en la red,
# no solo 'localhost'.
HOST_IP = "0.0.0.0"
HOST_PORT = 8000

def iniciar_servidor():
   """
   Función objetivo para el hilo del servidor.
   Inicia el servidor uvicorn. Esta es una llamada BLOQUEANTE
   que se ejecutará dentro de su propio hilo. 
   """
   print(f"Iniciando servidor FastAPI/uvicorn en http://{HOST_IP}:{HOST_PORT}")
   try:
       uvicorn.run(app_servidor, host=HOST_IP, port=HOST_PORT, log_level="info")
   except Exception as e:
       print(f"Error al iniciar el servidor uvicorn: {e}")

if __name__ == "__main__":
   # 1. Configurar el hilo del servidor
   # Creamos un hilo que tendrá como objetivo la función 'iniciar_servidor'.
   hilo_servidor = threading.Thread(target=iniciar_servidor)
   
   # Establecer como 'daemon=True'.
   # Esto significa que el hilo del servidor se cerrará automáticamente
   # cuando el hilo principal (la GUI) termine.
   hilo_servidor.daemon = True
   
   # 2. Iniciar el hilo del servidor
   # El servidor comenzará a escuchar peticiones en segundo plano.
   hilo_servidor.start()
   
   # 3. Iniciar la aplicación GUI
   # Creamos la instancia de la aplicación GUI.
   app_gui = AppMadre()
   
   # Iniciamos el bucle principal de la GUI.
   # Esta es una llamada BLOQUEANTE que se ejecutará en el hilo principal. 
   # La aplicación permanecerá aquí hasta que el usuario cierre la ventana.
   app_gui.mainloop()
   
   # Cuando el usuario cierra la ventana, app.mainloop() termina.
   # El programa principal finaliza, y como 'hilo_servidor' es un daemon,
   # se detendrá automáticamente.
   print("Aplicación Madre cerrada. Deteniendo el servidor...")

________________


III. Implementación de la Aplicación Hija (Cliente Remoto)


A continuación, se presenta la estructura de archivos y el código fuente completo y anotado para la Aplicación Hija. Esta implementación también respeta la restricción (3 archivos .py, que está dentro del límite de 4).


A. Estructura de Archivos (Total: 3 archivos.py)


1. hija_comms.py:
   * Propósito: Módulo de comunicaciones. Encapsula toda la lógica de red.
   * Contenido: Define una clase APICommunicator que utiliza la biblioteca requests para manejar las peticiones POST (autenticación) y GET (sincronización) a la API de la Madre.3
2. hija_views.py:
   * Propósito: Define los componentes de la GUI (las "vistas" o "páginas").
   * Contenido: Contiene las clases LoginFrame 1 y MainAppFrame, que heredan de customtkinter.CTkFrame. Estas clases son puramente visuales y emiten eventos a un controlador.
3. hija_main.py:
   * Propósito: Punto de entrada y controlador principal de la aplicación.
   * Contenido: Define la clase AppHija (la ventana raíz de CTk). Instancia el APICommunicator y gestiona el estado de la aplicación, implementando la lógica de "conmutación de frames" para pasar del LoginFrame al MainAppFrame tras una autenticación exitosa.7


B. Código Fuente Completo y Anotado: Aplicación Hija


A continuación se muestra el contenido de cada uno de los 3 archivos .py.


hija_comms.py




Python




# hija_comms.py
#
# Módulo de Comunicaciones de la Aplicación Hija.
# Encapsula toda la lógica de red usando la biblioteca 'requests'.
# Esto separa la lógica de la API de la lógica de la GUI.

import requests
import json

# --- Configuración de la Conexión ---
# IMPORTANTE: Reemplace '127.0.0.1' con la dirección IP real
# de la máquina donde se ejecuta la Aplicación Madre.
MADRE_BASE_URL = "http://127.0.0.1:8000"


class APICommunicator:
   """
   Gestiona todas las peticiones HTTP a la API de la Aplicación Madre.
   """
   def __init__(self, base_url: str = MADRE_BASE_URL):
       self.base_url = base_url
       self.session = requests.Session()
       self.session.headers.update({"Content-Type": "application/json"})

   def attempt_login(self, username: str) -> (bool, str):
       """
       Intenta autenticar al usuario contra el endpoint /autorizar. 
       
       Envía un POST con un payload JSON.
       Devuelve una tupla: (bool_exito, mensaje_o_error)
       """
       url = f"{self.base_url}/autorizar"
       payload = {"username": username}
       
       try:
           # Usar 'json=payload' hace que 'requests' automáticamente
           # serialice a JSON y establezca el header 'Content-Type'. 
           response = self.session.post(url, json=payload, timeout=5)
           
           # Comprobar si la petición fue exitosa a nivel de HTTP (ej. 200 OK)
           response.raise_for_status() 
           
           # Si llegamos aquí, la API respondió con 2xx
           data = response.json()
           if data.get("status") == "aprobado":
               return True, data.get("usuario", "Usuario aprobado")
           else:
               # Caso poco probable si la API está bien diseñada, pero se maneja
               return False, "Respuesta de API desconocida."
               
       except requests.exceptions.HTTPError as e:
           # Manejar errores de la API (ej. 403 Prohibido, 404 No Encontrado)
           try:
               error_detail = e.response.json().get("detail", "Error de servidor")
               return False, f"Error: {error_detail}"
           except json.JSONDecodeError:
               return False, f"Error HTTP {e.response.status_code}"
               
       except requests.exceptions.ConnectionError:
           # Manejar error de conexión (servidor no alcanzable)
           return False, "Error de conexión: No se pudo alcanzar la Aplicación Madre."
           
       except requests.exceptions.Timeout:
           # Manejar tiempo de espera agotado
           return False, "Error: La petición de conexión ha tardado demasiado."
           
       except Exception as e:
           # Manejar cualquier otro error inesperado
           return False, f"Un error inesperado ha ocurrido: {e}"

   def fetch_sync_data(self, username: str) -> (bool, dict):
       """
       Obtiene los datos de sincronización del endpoint /sincronizar_datos. 
       
       Envía un GET con el nombre de usuario como parámetro de consulta.
       Devuelve una tupla: (bool_exito, datos_o_error_msg)
       """
       url = f"{self.base_url}/sincronizar_datos"
       # 'params' construye automáticamente la URL query string:
       #.../sincronizar_datos?usuario=nombre_usuario [10]
       params = {"usuario": username}
       
       try:
           response = self.session.get(url, params=params, timeout=5)
           response.raise_for_status() # Lanza error para 4xx/5xx
           
           data = response.json()
           if data.get("status") == "sincronizacion_exitosa":
               return True, data.get("datos", {})
           else:
               return False, {"error": "Respuesta de sincronización inválida."}
               
       except requests.exceptions.HTTPError as e:
           try:
               error_detail = e.response.json().get("detail", "Error de servidor")
               return False, {"error": f"Error: {error_detail}"}
           except json.JSONDecodeError:
               return False, {"error": f"Error HTTP {e.response.status_code}"}
               
       except requests.exceptions.ConnectionError:
           return False, {"error": "Error de conexión."}
           
       except Exception as e:
           return False, {"error": f"Error inesperado: {e}"}



hija_views.py




Python




# hija_views.py
#
# Define las "vistas" o "páginas" de la aplicación Hija.
# Estas clases son componentes puros de GUI (CustomTkinter) que
# no contienen lógica de negocio o de red.
# Reciben un 'controlador' o 'comando' para notificar acciones del usuario.

import customtkinter

class LoginFrame(customtkinter.CTkFrame):
   """
   GUI para la pantalla de inicio de sesión. 
   Presenta un campo de entrada para el nombre de usuario y un botón de conexión.
   """
   def __init__(self, master, on_login_attempt, **kwargs):
       super().__init__(master, **kwargs)
       
       self.on_login_attempt = on_login_attempt # Callback al controlador
       
       # Frame interno para el efecto "tarjeta"
       card_frame = customtkinter.CTkFrame(self)
       card_frame.pack(pady=40, padx=40)

       lbl_title = customtkinter.CTkLabel(card_frame, text="Acceso de Cliente", font=customtkinter.CTkFont(size=20, weight="bold"))
       lbl_title.pack(pady=(20, 10), padx=30)

       self.entry_username = customtkinter.CTkEntry(card_frame, placeholder_text="Nombre de usuario", width=250)
       self.entry_username.pack(pady=12, padx=30)
       
       # Vincular la tecla "Enter" para que también intente el login
       self.entry_username.bind("<Return>", self._handle_login_event)

       self.btn_login = customtkinter.CTkButton(card_frame, text="Conectar a la Madre", command=self._handle_login_event)
       self.btn_login.pack(pady=12, padx=30)
       
       self.lbl_status = customtkinter.CTkLabel(card_frame, text="", text_color="red")
       self.lbl_status.pack(pady=(0, 20), padx=30)

   def _handle_login_event(self, event=None):
       """
       Manejador de eventos interno para el botón o la tecla Enter.
       Llama al callback del controlador.
       """
       username = self.entry_username.get()
       if not username:
           self.show_status("Por favor, ingrese un nombre de usuario.")
           return
           
       # Deshabilitar el botón para evitar clics múltiples
       self.btn_login.configure(text="Conectando...", state="disabled")
       self.lbl_status.configure(text="")
       
       # Llamar a la función del controlador (en hija_main.py)
       self.on_login_attempt(username)

   def show_status(self, message: str, is_error: bool = True):
       """Muestra un mensaje de estado (ej. un error) al usuario."""
       color = "red" if is_error else "green"
       self.lbl_status.configure(text=message, text_color=color)
       # Rehabilitar el botón
       self.btn_login.configure(text="Conectar a la Madre", state="normal")

   def get_username(self) -> str:
       """Devuelve el nombre de usuario ingresado."""
       return self.entry_username.get()


class MainAppFrame(customtkinter.CTkFrame):
   """
   GUI para la aplicación principal, mostrada después de un inicio de sesión exitoso.
   Esta es la interfaz "escalable y compleja" solicitada.
   Para el prototipo, contiene un área de bienvenida y la función de sincronización.
   """
   def __init__(self, master, username: str, on_sync_attempt, **kwargs):
       super().__init__(master, **kwargs)
       
       self.username = username
       self.on_sync_attempt = on_sync_attempt # Callback al controlador
       
       self.grid_columnconfigure(0, weight=1)
       self.grid_rowconfigure(1, weight=1)
       
       # --- Cabecera de Bienvenida ---
       header_frame = customtkinter.CTkFrame(self, fg_color="transparent")
       header_frame.grid(row=0, column=0, padx=20, pady=10, sticky="ew")
       
       lbl_welcome = customtkinter.CTkLabel(header_frame, text=f"Bienvenido, {self.username}", font=customtkinter.CTkFont(size=18, weight="bold"))
       lbl_welcome.pack(side="left")
       
       self.btn_sync = customtkinter.CTkButton(header_frame, text="Sincronizar con la Madre", command=self._handle_sync_event)
       self.btn_sync.pack(side="right")

       # --- Área de Contenido Principal ---
       # Para cumplir con la escalabilidad, se podría insertar un CTkTabview aquí.
       # Por simplicidad, mostramos un cuadro de texto para los datos sincronizados.
       content_frame = customtkinter.CTkFrame(self)
       content_frame.grid(row=1, column=0, padx=20, pady=10, sticky="nsew")
       content_frame.grid_columnconfigure(0, weight=1)
       content_frame.grid_rowconfigure(1, weight=1)

       lbl_content_title = customtkinter.CTkLabel(content_frame, text="Contenido Sincronizado de la Madre:")
       lbl_content_title.grid(row=0, column=0, padx=10, pady=(10, 5), sticky="w")
       
       self.textbox_content = customtkinter.CTkTextbox(content_frame, state="disabled")
       self.textbox_content.grid(row=1, column=0, padx=10, pady=(0, 10), sticky="nsew")

       # --- Pie de Página de Estado ---
       self.lbl_status = customtkinter.CTkLabel(self, text="Aplicación iniciada. Listo para sincronizar.", height=20)
       self.lbl_status.grid(row=2, column=0, padx=20, pady=5, sticky="w")

   def _handle_sync_event(self):
       """Manejador interno para el botón de sincronización."""
       self.btn_sync.configure(text="Sincronizando...", state="disabled")
       self.lbl_status.configure(text="Contactando a la Madre...", text_color="gray")
       
       # Llamar al callback del controlador (en hija_main.py)
       self.on_sync_attempt()

   def update_content(self, content: str, version: str):
       """Actualiza el cuadro de texto con el nuevo contenido sincronizado."""
       self.textbox_content.configure(state="normal") # Habilitar escritura
       self.textbox_content.delete("1.0", "end")
       self.textbox_content.insert("1.0", content)
       self.textbox_content.configure(state="disabled") # Deshabilitar escritura
       
       self.lbl_status.configure(text=f"Sincronización exitosa. Versión: {version}", text_color="green")
       self.btn_sync.configure(text="Sincronizar con la Madre", state="normal")

   def show_sync_error(self, message: str):
       """Muestra un error de sincronización."""
       self.lbl_status.configure(text=message, text_color="red")
       self.btn_sync.configure(text="Sincronizar con la Madre", state="normal")



hija_main.py




Python




# hija_main.py
#
# Punto de entrada principal y CONTROLADOR de la Aplicación Hija.
#
# Responsabilidades:
# 1. Crear la ventana raíz de CustomTkinter.
# 2. Instanciar el módulo de comunicaciones ('hija_comms').
# 3. Gestionar el estado de la aplicación, mostrando el 'LoginFrame'
#    o el 'MainAppFrame' según corresponda (Conmutación de Frames).
# 4. Proveer las funciones de callback que la GUI ('hija_views') ejecutará.

import customtkinter
from hija_comms import APICommunicator
from hija_views import LoginFrame, MainAppFrame

# Configuración inicial de apariencia
customtkinter.set_appearance_mode("system")
customtkinter.set_default_color_theme("blue")

class AppHija(customtkinter.CTk):
   """
   Clase principal de la aplicación Hija (Controlador).
   Hereda de CTk para ser la ventana raíz.
   """
   def __init__(self):
       super().__init__()
       
       self.title("Aplicación Hija")
       self.geometry("600x450")
       
       self.grid_columnconfigure(0, weight=1)
       self.grid_rowconfigure(0, weight=1)
       
       # --- Inicialización del Controlador ---
       self.communicator = APICommunicator()
       self.current_username = None
       
       # --- Almacenamiento de Vistas ---
       # El patrón de "conmutación de frames" implica destruir y crear
       # los frames principales. 
       self._current_frame = None
       
       # Iniciar el flujo de la aplicación mostrando el Login
       self._mostrar_login()

   def _limpiar_frames_actuales(self):
       """
       Destruye el frame actual para hacer espacio para el siguiente.
       """
       if self._current_frame:
           self._current_frame.pack_forget()
           self._current_frame.destroy()
           self._current_frame = None

   def _mostrar_login(self):
       """
       Crea y muestra el LoginFrame.
       """
       self._limpiar_frames_actuales()
       
       self.title("Aplicación Hija - Iniciar Sesión")
       self.geometry("600x450")
       
       # Instanciar el LoginFrame, pasándole '_intentar_login' como
       # el callback 'on_login_attempt'.
       self._current_frame = LoginFrame(master=self, on_login_attempt=self._intentar_login)
       self._current_frame.pack(padx=20, pady=20, fill="both", expand=True)

   def _intentar_login(self, username: str):
       """
       Callback de lógica de negocio. Es llamado por LoginFrame.
       Usa el 'communicator' para intentar el login.
       """
       success, message = self.communicator.attempt_login(username)
       
       if success:
           self.current_username = message # El mensaje de éxito es el nombre de usuario
           # Transición a la aplicación principal
           self._mostrar_app_principal()
       else:
           # Mostrar el error en la GUI de Login
           # Necesitamos acceder al método 'show_status' del frame de login
           if isinstance(self._current_frame, LoginFrame):
               self._current_frame.show_status(message, is_error=True)

   def _mostrar_app_principal(self):
       """
       Crea y muestra el MainAppFrame después de un login exitoso.
       """
       self._limpiar_frames_actuales()
       
       self.title(f"Aplicación Hija - {self.current_username}")
       self.geometry("700x500")
       
       # Instanciar el MainAppFrame, pasando el nombre de usuario
       # y el callback de sincronización.
       self._current_frame = MainAppFrame(
           master=self,
           username=self.current_username,
           on_sync_attempt=self._intentar_sync
       )
       self._current_frame.pack(fill="both", expand=True)

   def _intentar_sync(self):
       """
       Callback de lógica de negocio. Es llamado por MainAppFrame.
       Usa el 'communicator' para obtener datos de sincronización.
       """
       if not self.current_username:
           print("Error crítico: Intento de sincronización sin usuario logueado.")
           return
           
       success, data = self.communicator.fetch_sync_data(self.current_username)
       
       if isinstance(self._current_frame, MainAppFrame):
           if success:
               # Si es exitoso, 'data' es un diccionario con el contenido
               contenido = data.get("contenido", "No se recibió contenido.")
               version = data.get("metadatos_version", "N/A")
               self._current_frame.update_content(contenido, version)
           else:
               # Si falla, 'data' es un diccionario con un error
               error_msg = data.get("error", "Error de sincronización desconocido.")
               self._current_frame.show_sync_error(error_msg)

# --- Punto de Entrada ---
if __name__ == "__main__":
   app = AppHija()
   app.mainloop()

________________


IV. Conclusión, Escalabilidad y Próximos Pasos




A. Resumen de la Implementación


Este informe ha entregado un prototipo funcional (Prueba de Concepto) que cumple con todos los requisitos funcionales y de arquitectura de la solicitud. La arquitectura seleccionada, que combina CustomTkinter para una GUI moderna, FastAPI para un backend de API robusto, y threading para la concurrencia en el servidor, ha demostrado ser una pila tecnológica moderna, eficaz y escalable para la plataforma Windows en Python.
La Aplicación Hija cumple con el flujo de "autenticación para iniciar", y la Aplicación Madre funciona simultáneamente como un panel de gestión y un servidor de API, todo dentro de las estrictas restricciones de 4 archivos .py por aplicación.


B. Consideraciones de Seguridad Críticas para la Producción


El prototipo actual es funcionalmente correcto pero no es seguro para un entorno de producción. Su principal vulnerabilidad es que la autorización se basa únicamente en un nombre_de_usuario enviado en texto plano. Esto expone el sistema a ataques de suplantación de identidad (spoofing).
La investigación apunta a la solución estándar de la industria. El siguiente paso crítico es implementar OAuth2 con JSON Web Tokens (JWT), un estándar que FastAPI soporta de manera nativa.22
El flujo de producción recomendado sería:
1. Solicitud de Token: La Hija recolecta nombre_de_usuario y contraseña (que también se gestionaría en la GUI de la Madre). Envía estos datos a un nuevo endpoint de FastAPI, /token.23
2. Emisión de Token: La Madre verifica las credenciales. Si son válidas, genera un access_token (un JWT firmado) y lo devuelve a la Hija.
3. Almacenamiento de Token: La Hija almacena este token de forma segura en memoria.
4. Peticiones Autenticadas: Para todas las solicitudes futuras (como /sincronizar_datos), la Hija ya no envía su nombre de usuario como parámetro. En su lugar, incluye el token en la cabecera de la petición: Authorization: Bearer <token_jwt>.32
5. Verificación de Token: La Madre utiliza las dependencias de seguridad de FastAPI para validar el token en cada petición, asegurando que sea válido y extrayendo la identidad del usuario directamente del token.


C. Estrategias de "Complejización" y Despliegue


El prototipo actual está diseñado para ser la base de las aplicaciones "complejas y escalables" solicitadas. Los próximos pasos para alcanzar ese objetivo son:
1. Empaquetado y Despliegue: Para distribuir las Aplicaciones Hijas en múltiples equipos Windows, se debe utilizar una herramienta como PyInstaller. PyInstaller analizará los scripts de Python (ej. hija_main.py y sus importaciones) y los empaquetará, junto con el intérprete de Python y todas las dependencias (como customtkinter y requests), en un único archivo .exe ejecutable. Esto permite una distribución simple sin necesidad de que los clientes instalen Python.
2. Escalabilidad de la GUI: La "complejidad" de las aplicaciones Hija y Madre se puede lograr expandiendo el diseño actual. El MainAppFrame de la Hija puede ser reemplazado por su propio CTkTabview 26, permitiendo múltiples pantallas complejas (ej. "Dashboard", "Configuración", "Módulos de Trabajo") dentro de la misma aplicación, reflejando la estructura modular de la Madre.
3. Persistencia de la Base de Datos: El módulo madre_db.py (un diccionario de Python) es una solución temporal. Debe ser reemplazado por una base de datos real. Para una escala pequeña o mediana, SQLite es una excelente opción que se integra fácilmente. Para una escala mayor, se recomendaría una base de datos como PostgreSQL, utilizando SQLAlchemy como ORM, que se integra perfectamente con los modelos Pydantic de FastAPI.33
4. Comunicaciones Seguras (HTTPS): Toda la comunicación de red en producción debe estar cifrada usando HTTPS. Aunque uvicorn puede configurarse para servir sobre SSL/TLS, la práctica estándar de la industria es desplegar el servidor FastAPI detrás de un proxy inverso (como Nginx o Traefik). El proxy inverso manejaría la terminación SSL (HTTPS) 22 y reenviaría el tráfico de forma segura a la aplicación FastAPI, que seguiría ejecutándose en el hilo de fondo de la Aplicación Madre.
1.